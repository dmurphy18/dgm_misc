#!/bin/bash


usage() {
  echo ""
  echo "usage: ${0} [-v|--verbose] [-d|--debug] [-h|--help] [-l|--log <debug>] [-t|--tag <tag>]"
  echo ""
  echo "  -v, --verbose   verbose output"
  echo "  -d, --debug     debug output enabled"
  echo "  -h, --help      this message"
  echo "  -l, --log       logging mode"
  echo "  -t, --tag       build's tag, e.g. 2014.7.2, if unspecified YYYY-MM-DD-HH-MM-SS"
  echo ""
}

error_exit() {
  [[ ${op_status} = "ERRORS" ]] && {
    ## fire and event for stating completion with grains and a data dictionary
    salt-call event.send '/salt-internal/build_server/build_result_bad' changed="${op_changed}" comment="${op_comment}" status="${op_status}" log="${op_log}" bld_product="${op_bld_product}" with_grains=True

    ## last lines - still need this even if fire event
    echo ""     ## this echos an empty line and is required
    echo "name=${0} changed=${op_changed} result='False' comment='${op_bld_product}'"
    exit 1
  }
}

success_exit() {
  ## fire and event for stating completion with grains and a data dictionary
  salt-call event.send '/salt-internal/build_server/build_result_good' changed="${op_changed}" comment="${op_comment}" status="${op_status}" log="${op_log}" bld_product="${op_bld_product}" with_grains=True

  ## last lines - still need this even if fire event
  echo ""     ## this echos an empty line and is required
  echo "name=${0} changed=${op_changed} result='True' comment='${op_bld_product}_resout'"
  exit 0
}

# parameter parsing

## using 'GNU getopt' with support for long keywords, 
## requires separate install on OSX and FreeBSD
#TEMP=$(getopt -o vdhlt: --long verbose,debug,help,log:,tag: -n 'bldscript' -- "$@")
#
#eval set -- "${TEMP}"
#
VERBOSE=false
DEBUG=false
USAGE_HELP=false
LOG_MODE='debug'
RELEASE_TAG=

while true; do
  case "${1}" in
    -v | --verbose ) VERBOSE=true; shift ;;
    -d | --debug )  DEBUG=true; shift ;;
    -h | --help ) USAGE_HELP=true; shift ;;
    -l | --log )  LOG_MODE="$2"; shift 2 ;;
    -t | --tag ) RELEASE_TAG="$2"; shift 2 ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

## check if want help, display usage and exit
[[ ${USAGE_HELP} = 'false' ]] || {
  usage
  exit 0
}

# log and build product names, cp.push needs abs paths
curr_path=$(pwd)
op_log="${curr_path}/build-test.log"
op_bld_product="${curr_path}/platform_product.blt"

# define output for exit
op_changed=no
op_comment="failures occured"
op_status="ERRORS"

trap error_exit SIGHUP SIGINT SIGQUIT SIGABRT SIGTERM EXIT

cat <<@EOF > "${op_log}"
The test log for the build script bldscript
The laxy dog jumped the brown cow and it belched
@EOF

cat <<@EOF > "${op_bld_product}"
This si just something signifing that the product was
built for the platform.
@EOF


# echo "testing bldscript trap handling"
#sleep 10
# echo "done sleeping"
op_status="GOOD"
op_comment="test bldscript output"

salt-call cp.push "${op_log}"
salt-call cp.push "${op_bld_product}"

success_exit

